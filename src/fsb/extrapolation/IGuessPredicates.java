package fsb.extrapolation;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import com.microsoft.z3.Context;
import com.microsoft.z3.Expr;

import fsb.ast.AssertComparsionBool;
import fsb.ast.AssertConstExpr;
import fsb.ast.AssertPC;
import fsb.ast.BoolExpr;
import fsb.ast.BoolExpr.BXType;
import fsb.explore.Action;
import fsb.explore.ExprValidator;
import fsb.explore.SBState;
import fsb.explore.State;
import fsb.explore.Validator;
import fsb.semantics.sc.SCState;
import fsb.tvl.ArithValue;
import fsb.tvl.DetArithValue;
import fsb.utils.Options;
import fsb.z3.Z3ExprToAstBoolExpr;
import fsb.z3.Z3Printer;

public abstract class IGuessPredicates {


	/**
	 * @param predicates list of current predicates used to obtain the trace
	 * @param concrete_trace error trace generated by the model checker
	 * @return list of new predicates to refine the abstraction as Strings
	 */
	public List<String> guessStringPredicates(ArrayList<fsb.ast.BoolExpr> predicates, ArrayList<Action> concrete_trace) {
	  	
		return z3ExprToString(guessZ3ExprPredicates(predicates,concrete_trace));
	}
	
	/**
	 * @param predicates list of current predicates used to obtain the trace
	 * @param concrete_trace error trace generated by the model checker
	 * @return list of new predicates to refine the abstraction as {@link fsb.ast.BoolExp}
	 */
	public List<fsb.ast.BoolExpr> guessAstBoolExp(ArrayList<fsb.ast.BoolExpr> predicates, ArrayList<Action> concrete_trace) {
		
		return z3ExprToBoolExpr(guessZ3ExprPredicates(predicates,concrete_trace));
	}
	
	/**
	 * @param predicates list of current predicates used to obtain the trace
	 * @param concrete_trace error trace generated by the model checker
	 * @return list of new predicates to refine the abstraction as {@link com.microsoft.z3.Expr}
	 */
	abstract protected List<Expr> guessZ3ExprPredicates(ArrayList<fsb.ast.BoolExpr> predicates, ArrayList<Action> concrete_trace);

	
	/*
	 * methods for inheriting classes to use
	 * 
	 */
	
	abstract protected Context initZ3() ;
	
	protected static boolean isBooleanPredicate(Expr e){
        if(e.isLE() || e.isGE() || e.isEq() || e.isGT() || e.isLT() 
                || (e.isNot() && isBooleanPredicate(e.getArgs()[0]))){
            return true;
        }
        System.out.println("filtering out: " + e);
        System.out.println("in infix: " + Z3Printer.toString(e));
        return false;
    }
	
	protected static List<String> z3ExprToString(List<Expr> predicates) {
	    return predicates.stream().filter(p->isBooleanPredicate(p)).map(p->Z3Printer.toString(p.simplify())).collect(Collectors.<String> toList());
	}
	
	protected static List<fsb.ast.BoolExpr> z3ExprToBoolExpr(List<Expr> predicates) {
	    return predicates.stream().filter(p->isBooleanPredicate(p)).map(p->Z3ExprToAstBoolExpr.toBoolExpr(p.simplify())).collect(Collectors.<BoolExpr> toList());
	}
	
	protected static List<String> boolExprToStrings(List<fsb.ast.BoolExpr> predicates) {
	    return predicates.stream().map(p->p.toString()).collect(Collectors.<String> toList());
	}

	protected ArrayList<com.microsoft.z3.BoolExpr> extractFinalStateForZ3(ArrayList<fsb.ast.BoolExpr> predicates, SCState finalState, Context ctx) {
		
		
		ArrayList<com.microsoft.z3.BoolExpr> literals = new ArrayList<>();
		
		/* Add program counter values to the Z3 final state formula */
		literals.addAll(addToZ3StateThePC(finalState, ctx));
		
		/* Add predicates (or their negation) to the final state formula */
		for (int i = 0; i < predicates.size(); i++) {
			ArithValue val = finalState.getShared(i);
			com.microsoft.z3.BoolExpr predZ3 = predicates.get(i).toZ3(ctx);
			if (val.isDetermined()) {
				int v = ((DetArithValue)val).getValue();
				if (v == 1) { // predicate is true
					literals.add(predZ3);
				} else if (v == 0) { // predicate is false
					literals.add(ctx.mkNot(predZ3));
				} else { // unexpected value
					throw new IllegalStateException("Unexpected value for determined predicate");
				}
			} else { // predicate is *, don't add it to the state
				
			}
		}
		
		/* Add negation of the assertion to the final state formula */
		Validator v = State.program.getValidator();
		if (v instanceof ExprValidator) {
		    com.microsoft.z3.BoolExpr assertionZ3 = ((ExprValidator)v).toZ3(ctx, predicates);
		    literals.add(ctx.mkNot(assertionZ3));
		}
		
	    
	    
		return literals;
	}



	protected ArrayList<com.microsoft.z3.BoolExpr> addToZ3StateThePC(SCState state, Context ctx) {
		ArrayList<com.microsoft.z3.BoolExpr> state_formulas = new ArrayList<>();
		int n = state.getProcs();
		for (int i = 1; i < n; i++) {
		    int currRealPC = ((SBState) state).getPC(i);
		    int label = State.program.getListing(i).get(currRealPC).getLabel();
		    state_formulas.add(new AssertComparsionBool(new AssertPC(i), new AssertConstExpr(label), BXType.EQUAL).toZ3(ctx));
		}
		return state_formulas;
	}
	/**
	 * recursive predicate filtering and splitting
	 * @param predicates
	 * @return
	 */
	protected static List<String> Z3toStringSplitPreds(Expr[] predicates) {
		List<String> arr = new ArrayList<>(); 
		for(Expr e : predicates){
			if(e.isAnd() || e.isOr() || e.isNot() || e.isIff()){
				arr.addAll(Z3toStringSplitPreds(e.getArgs()));
				if(Options.ADD_SYTHESIZED_CUBE_PRED){
					arr.add(Z3Printer.toString(e));
				}
			}else if(isBooleanPredicate(e)){
				arr.add(Z3Printer.toString(e));
			}else{
				throw new IllegalStateException("not sure what to do with predicate: " + e.toString());
			}
			
		}
			
	    return arr;
	}

	
	


	/**
	 * receives an array of Z3 predicates, maybe complex (with an and with or) and extract the components <br>
	 * p1 && p2 - > {p1,p2}<br>
	 * if {@link Options.#ADD_SYTHESIZED_CUBE_PRED} is set then the complex predicate is added as well.
	 * @see Z3toStreamFlatten
	 * @param predicates
	 * @return
	 */
	protected static Stream<Expr> Z3toStreamFlatten(Expr[] predicates) {
		return Stream.of(predicates).flatMap(IGuessPredicates::Z3toStreamFlatten);
	}
	
	/**
	 * p1 && p2 - > {p1,p2} <br>
	 * if {@link Options.#ADD_SYTHESIZED_CUBE_PRED} is set then the complex predicate is added as well.
	 * @see Z3toStreamFlatten
	 * @param predicates
	 * @return
	 */
	protected static Stream<Expr> Z3toStreamFlatten(Expr e) {
		if(e.isAnd() || e.isOr() || e.isNot() || e.isIff()){
			return Stream.concat(Z3toStreamFlatten(e.getArgs()),
					(Options.ADD_SYTHESIZED_CUBE_PRED)? Stream.empty() :Stream.of(e));
			
		}else if(isBooleanPredicate(e)){
			return Stream.of(e);
		}//else{
		
		throw new IllegalStateException("not sure what to do with predicate: " + e.toString());		
	}

}